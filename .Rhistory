recipe(status ~ .) %>%
# Imputation: assigning NAs to a new level for categorical and
# median imputation for numeric
step_unknown(all_nominal(), -status) %>%
step_medianimpute(all_numeric()) %>%
# Combining infrequent categorical levels and introducing a new level
# for prediction time
step_other(all_nominal(), -status, other = "infrequent_combined") %>%
step_novel(all_nominal(), -status, new_level = "unrecorded_observation") %>%
# Hot-encoding categorical variables
step_dummy(all_nominal(), -status, one_hot = TRUE) %>%
# Adding upsampling
step_upsample(status, over_ratio = tune())
fits <- tune_grid(
recipe,
model = engine,
rs = train_cv,
grid = grid,
perf = metric_set(pr_auc, j_index, sens, spec),
control = grid_control(verbose = FALSE)
)
fits
summarize(fits) %>%
arrange(desc(over_ratio))
summarize(fits) %>%
mutate(
over_ratio = as.factor(round(over_ratio, 2))
) %>%
rename(
Metric = .metric
) %>%
ggrapid::plot_line(
over_ratio,
mean,
fill = Metric,
title = "Performance metrics across different upsampling ratios values",
caption = "Upsampling ratio = 1 - equal number of observations between classes",
lab_x = "Upsampling ratio between both classes",
lab_y = "Performance metric value",
angle = 0,
limit_max = 1
)
?df_train
set.seed(42)
options(max.print = 150)
library(tidymodels)
library(magrittr)
library(tune)
data("credit_data")
credit_data %<>%
set_names(., tolower(names(.)))
prop.table(table(credit_data$status))
split <- initial_split(credit_data, prop = 0.80, strata = "status")
df_train <- training(split)
df_test  <- testing(split)
train_cv <- vfold_cv(df_train, v = 5, repeats = 5, strata = "status")
glimpse(df_train)
recipe <- df_train %>%
recipe(status ~ .) %>%
# Imputation: assigning NAs to a new level for categorical and
# median imputation for numeric
step_unknown(all_nominal(), -status) %>%
step_medianimpute(all_numeric()) %>%
# Combining infrequent categorical levels and introducing a new level
# for prediction time
step_other(all_nominal(), -status, other = "infrequent_combined") %>%
step_novel(all_nominal(), -status, new_level = "unrecorded_observation") %>%
# Hot-encoding categorical variables
step_dummy(all_nominal(), -status, one_hot = TRUE) %>%
# Creating additional variables
step_mutate(
ratio_expenses_income = expenses / (income + 0.001),
ratio_assets_income = assets / (income + 0.001),
ratio_debt_income = debt / (income + 0.001),
ratio_debt_assets = debt / (assets + 0.001),
ratio_amout_price = amount / (price + 0.001)
) %>%
# Adding upsampling
step_upsample(status, over_ratio = tune())
(grid <- grid_random(
over_ratio() %>% range_set(c(0.5, 1.5)),
size = 10
))
fits <- tune_grid(
recipe,
model = engine,
rs = train_cv,
grid = grid,
perf = metric_set(pr_auc, j_index, sens, spec),
control = grid_control(verbose = FALSE)
)
fits
engine
model <- workflow() %>%
add_model(engine) %>%
add_recipe(recipe)
model
param_set(model)
model <- workflow() %>%
add_model(engine) %>%
add_recipe(recipe) %>%
update(over_ratio = 1.06)
over_ratio(1.06)
model <- workflow() %>%
add_model(engine) %>%
add_recipe(recipe) %>%
update(over_ratio = over_ratio(1.06))
model <- workflow() %>%
add_model(engine) %>%
add_recipe(recipe) %>%
update(over_ratio = over_ratio(c(1.06)))
over_ratio
over_ratio()
over_ratio(c(1)))
over_ratio(c(1))
over_ratio(1)
value_set(1)
model <- workflow() %>%
add_model(engine) %>%
add_recipe(recipe) %>%
param_set()
model
model <- workflow() %>%
add_model(engine) %>%
add_recipe(recipe) %>%
param_set() %>%
update(over_ratio = over_ratio(1))
model <- workflow() %>%
add_model(engine) %>%
add_recipe(recipe) %>%
param_set() %>%
update(over_ratio = over_ratio(c(1)))
model <- workflow() %>%
add_model(engine) %>%
add_recipe(recipe) %>%
param_set() %>%
update(over_ratio = over_ratio(1))
model <- workflow() %>%
add_model(engine) %>%
add_recipe(recipe) %>%
param_set() %>%
update(over_ratio = 1)
model <- workflow() %>%
add_model(engine) %>%
add_recipe(recipe)
model <- workflow() %>%
add_model(engine) %>%
add_recipe(recipe)
param <- param_set(model)
param <- param %>%
update(over_ratio = over_ratio(1))
param <- param %>%
update(over_ratio = over_ratio(c(1)))
param <- param %>%
update(over_ratio = over_ratio(c(1, 2)))
param
model <- workflow() %>%
add_model(engine) %>%
add_recipe(recipe)
param <- param_set(model)
param
?param_set
?tune::param_set
?dials::param_set
model <- workflow() %>%
add_model(engine) %>%
add_recipe(recipe)
param <- param_set(model)
param <- param %>%
update(over_ratio = over_ratio(c(1, 1)))
?tune::add_model()
model
param_set(model)
?update
?tune_grid()
?tune_args()
model <- workflow() %>%
add_model(engine) %>%
add_recipe(recipe) %>%
fit()
install.packages("doFuture")
devtools::install_github("tidymodels/tune")
install.packages("recipes")
require("tune")
?require
if(!require("tune")){
devtools::install_github("tidymodels/tune")
}
remove.packages("tune")
if(!require("tune")){
devtools::install_github("tidymodels/tune")
}
devtools::install_github("tidymodels/tune")
set.seed(42)
options(max.print = 150)
library(tidymodels)
install.packages("tidymodels")
install.packages("tidymodels")
set.seed(42)
options(max.print = 150)
library(tidymodels)
library(magrittr)
library(tune)
all_cores <- parallel::detectCores(logical = FALSE)
library(doFuture)
registerDoFuture()
cl <- makeCluster(all_cores)
cl
cluster
parallel::detectCores()
all_cores <- parallel::detectCores(logical = FALSE)
library(doFuture)
registerDoFuture()
cl <- makeCluster(all_cores)
plan(cluster, workers = cl)
all_cores
parallel::detectCores
parallel::detectCores()
all_cores <- parallel::detectCores(logical = FALSE)
all_cores
parallel::detectCores()
?parallel::detectCores()
?credit_data
data("credit_data")
credit_data %<>%
set_names(., tolower(names(.)))
prop.table(table(credit_data$status))
prop.table(table(credit_data$status))
(engine <- rand_forest(
mtry = 2,
trees = 500,
min_n = 10
) %>%
set_mode("classification") %>%
set_engine("ranger"))
?rand_forest
library(parsnip)
(engine <- rand_forest(
mtry = 2,
trees = 500,
min_n = 10
) %>%
set_mode("classification") %>%
set_engine("ranger"))
(grid <- grid_random(
over_ratio() %>% range_set(c(0.5, 1.5)),
size = 10
))
library(dials)
?grid_random
library(dials)
install.packages("dials")
knitr::opts_chunk$set(
collapse = TRUE,
warning = FALSE,
message = FALSE
)
devtools::install_github("tidymodels/tune")
install.packages("tidymodels")
?tidymodels
set.seed(42)
options(max.print = 150)
library(doFuture)
library(magrittr)
library(tidymodels)
library(parsnip)
library(tune)
set.seed(42)
options(max.print = 150)
library(doFuture)
library(magrittr)
library(parsnip)
library(tune)
knitr::opts_chunk$set(
collapse = TRUE,
warning = FALSE,
message = FALSE
)
set.seed(42)
options(max.print = 150)
library(doFuture)
library(magrittr)
library(parsnip)
library(tune)
set.seed(42)
options(max.print = 150)
library(doFuture)
library(magrittr)
# library(parsnip)
# library(tune)
library(tidymodels)
library(dials)
library(tune)
devtools::install_github("tidymodels/dials")
devtools::install_github("tidymodels/parsnip")
knitr::opts_chunk$set(
collapse = TRUE,
warning = FALSE,
message = FALSE
)
devtools::install_github("tidymodels/dials")
devtools::install_github("tidymodels/parsnip")
devtools::install_github("tidymodels/tune")
library(parsnip)
library(dials)
library(tune)
library(tidymodels)
set.seed(42)
options(max.print = 150)
library(doFuture)
library(magrittr)
all_cores <- parallel::detectCores(logical = FALSE)
registerDoFuture()
cl <- makeCluster(all_cores)
plan(cluster, workers = cl)
data("credit_data")
credit_data %<>%
set_names(., tolower(names(.)))
prop.table(table(credit_data$status))
split <- initial_split(credit_data, prop = 0.80, strata = "status")
df_train <- training(split)
df_test  <- testing(split)
train_cv <- vfold_cv(df_train, v = 5, repeats = 3, strata = "status")
round(prop.table(table(credit_data$status)), 2)
(engine <- rand_forest(
mtry = 2,
trees = 500,
min_n = 10
) %>%
set_mode("classification") %>%
set_engine("ranger"))
recipe <- df_train %>%
recipe(status ~ .) %>%
# Imputation: assigning NAs to a new level for categorical
# (that's good practice, but not needed here) and median imputation for numeric
step_unknown(all_nominal(), -status) %>%
step_medianimpute(all_numeric()) %>%
# Combining infrequent categorical levels and introducing a new level
# for prediction time (that's good practice, but not needed here)
step_other(all_nominal(), -status, other = "infrequent_combined") %>%
step_novel(all_nominal(), -status, new_level = "unrecorded_observation") %>%
# Hot-encoding categorical variables
step_dummy(all_nominal(), -status, one_hot = TRUE) %>%
# Creating additional ratio variables - they typically make sense
# in credit scoring problems
step_mutate(
ratio_expenses_income = expenses / (income + 0.001),
ratio_assets_income = assets / (income + 0.001),
ratio_debt_income = debt / (income + 0.001),
ratio_debt_assets = debt / (assets + 0.001),
ratio_amout_price = amount / (price + 0.001)
) %>%
# Adding upsampling
step_upsample(status, over_ratio = tune())
(grid <- grid_random(
over_ratio() %>% range_set(c(0.5, 1.5)),
size = 10
))
?over_ratio()
?recipes::step_upsample()
?grid_control
?pr_auc
?grid_control
all_cores <- parallel::detectCores(logical = FALSE)
registerDoFuture()
cl <- makeCluster(all_cores)
plan(cluster, workers = cl)
cl
fits <- tune_grid(
recipe,
model = engine,
rs = train_cv,
grid = grid,
perf = metric_set(roc_auc, j_index, sens, spec),
control = grid_control(verbose = FALSE)
)
summarize(fits) %>%
arrange(desc(over_ratio))
fits
summarize(fits)
?summarize
estimate(fits)
fits[1, ]$.metrics
estimate(fits) %>%
arrange(desc(over_ratio))
fits
fits
estimate(fits) %>%
mutate(
over_ratio = as.factor(round(over_ratio, 2))
) %>%
rename(
Metric = .metric
) %>%
ggrapid::plot_line(
over_ratio,
mean,
fill = Metric,
title = "Performance metrics across different upsampling ratios values",
caption = "Upsampling ratio = 1 - equal number of observations between classes",
lab_x = "Upsampling ratio between both classes",
lab_y = "Performance metric value",
angle = 0,
limit_max = 1
)
c(0.5, 1.5)
range_set(c(0.5, 1.5))
range_set
?range_set
over_ratio()
over_ratio() %>% range_set(c(0.5, 1.5))
?grid_random
?grid_regular
(grid <- grid_regular(
over_ratio() %>% range_set(c(0.5, 1.5)),
size = 10
))
(grid <- grid_regular(
over_ratio() %>% range_set(c(0.5, 1.5)),
levels = 10
))
?seq()
seq(0.5, 1.5, length.out = 0.01)
seq(0.5, 1.5, length.out = 0.1)
seq(0.5, 1.5, by = 0.1)
(grid <- grid_regular(
over_ratio = seq(0.5, 1.5, by = 0.1),
levels = 10
))
over_ratio()
?over_ratio()
# (grid <- grid_regular(
#   over_ratio() %>% range_set(c(0.5, 1.5)),
#   levels = 10
#   ))
(grid <- grid_regular(
seq(0.5, 1.5, by = 0.1),
levels = 10
))
?grid_regular
# (grid <- grid_regular(
#   over_ratio() %>% range_set(c(0.5, 1.5)),
#   levels = 10
#   ))
(grid <- grid_regular(
list(seq(0.5, 1.5, by = 0.1)),
levels = 10
))
(grid <- grid_regular(
list(test = seq(0.5, 1.5, by = 0.1)),
levels = 10
))
?value_set()
over_ratio() %>% value_set(c(1, 2))
over_ratio() %>% value_set(c(1, 1.5))
over_ratio() %>% value_set(c(1))
over_ratio() %>% range_set(c(0.5, 1.5))
cost_complexity()
cost_complexity() %>% value_sample(2)
over_ratio() %>% value_set(1:1.1)
over_ratio() %>% range_set(c(0.5, 1.5))
over_ratio() %>% range_set(c(0.5, 1.5)) %>% value_seq(10)
over_ratio() %>% range_set(c(0.5, 1.5)) %>% value_seq(10)
(grid <- grid_regular(
over_ratio() %>% range_set(c(0.5, 1.5)),
levels = 10
))
over_ratio() %>% range_set(c(0.5, 1.5))
seq(0.5, 1.5, by = 0.1)
grid <- tibble(over_ratio = seq(0.5, 1.5, by = 0.1))
grid
param_set
?param_set
(grid <- grid_regular(
over_ratio() %>% range_set(c(0.5, 1.5)),
levels = 10
))
(grid <- tibble(over_ratio = seq(0.5, 1.5, by = 0.1))) # more granular
fits <- tune_grid(
recipe,
model = engine,
rs = train_cv,
grid = grid,
perf = metric_set(roc_auc, j_index, sens, spec),
control = grid_control(verbose = FALSE)
)
(grid <- grid_regular(
over_ratio() %>% range_set(c(0.5, 1.5)),
levels = 10
))
(grid <- grid_regular(
over_ratio() %>% range_set(c(0.5, 1.5)),
levels = 10
))
(grid <- grid_regular(
over_ratio() %>% range_set(c(0.5, 1.5)),
levels = 11
))
tibble(over_ratio = seq(0.5, 1.5, by = 0.1)))
tibble(over_ratio = seq(0.5, 1.5, by = 0.1))
(grid <- grid_regular(
over_ratio() %>% range_set(c(0.5, 1.5)),
levels = 11
))
fits <- tune_grid(
recipe,
model = engine,
rs = train_cv,
grid = grid,
perf = metric_set(roc_auc, j_index, sens, spec),
control = grid_control(verbose = FALSE)
)
